# coding: utf-8

"""
    Torizon IDE-backend API

    Toradex API to build and deploy applications running as containers on Torizon  # noqa: E501

    The version of the OpenAPI document: 1.1.1
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from moses_client.api_client import ApiClient
from moses_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ApplicationsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def application_build(self, application_id, configuration, **kwargs):  # noqa: E501
        """Build container image  # noqa: E501

        Build application release or debug container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_build(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param progress_id: Id of a progress cookie (uuid)
        :type progress_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_build_with_http_info(application_id, configuration, **kwargs)  # noqa: E501

    def application_build_with_http_info(self, application_id, configuration, **kwargs):  # noqa: E501
        """Build container image  # noqa: E501

        Build application release or debug container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_build_with_http_info(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param progress_id: Id of a progress cookie (uuid)
        :type progress_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'progress_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_build" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_build`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_build`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_build`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_build`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'progress_id' in local_var_params and not re.search(r'^$|[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['progress_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `progress_id` when calling `application_build`, must conform to the pattern `/^$|[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'progress_id' in local_var_params and local_var_params['progress_id'] is not None:  # noqa: E501
            query_params.append(('progress_id', local_var_params['progress_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/applications/{application_id}/build', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_delete(self, application_id, **kwargs):  # noqa: E501
        """Remove an application  # noqa: E501

        Remove an application and all the associated data and containers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_delete(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_delete_with_http_info(application_id, **kwargs)  # noqa: E501

    def application_delete_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """Remove an application  # noqa: E501

        Remove an application and all the associated data and containers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_delete_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_delete`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_delete`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/applications/{application_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_deploy(self, application_id, configuration, device_id, **kwargs):  # noqa: E501
        """Deploy container image  # noqa: E501

        Deploy application container to target  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_deploy(application_id, configuration, device_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param device_id: Target device serial number (required)
        :type device_id: str
        :param progress_id: Id of a progress cookie (uuid)
        :type progress_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_deploy_with_http_info(application_id, configuration, device_id, **kwargs)  # noqa: E501

    def application_deploy_with_http_info(self, application_id, configuration, device_id, **kwargs):  # noqa: E501
        """Deploy container image  # noqa: E501

        Deploy application container to target  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_deploy_with_http_info(application_id, configuration, device_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param device_id: Target device serial number (required)
        :type device_id: str
        :param progress_id: Id of a progress cookie (uuid)
        :type progress_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'device_id',
            'progress_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_deploy" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_deploy`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_deploy`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if self.api_client.client_side_validation and ('device_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['device_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `device_id` when calling `application_deploy`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_deploy`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_deploy`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'device_id' in local_var_params and not re.search(r'^[-0-9a-zA-Z.]*$', local_var_params['device_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `device_id` when calling `application_deploy`, must conform to the pattern `/^[-0-9a-zA-Z.]*$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'progress_id' in local_var_params and not re.search(r'^$|[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['progress_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `progress_id` when calling `application_deploy`, must conform to the pattern `/^$|[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'device_id' in local_var_params and local_var_params['device_id'] is not None:  # noqa: E501
            query_params.append(('device_id', local_var_params['device_id']))  # noqa: E501
        if 'progress_id' in local_var_params and local_var_params['progress_id'] is not None:  # noqa: E501
            query_params.append(('progress_id', local_var_params['progress_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/applications/{application_id}/deploy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_get(self, application_id, **kwargs):  # noqa: E501
        """Get application  # noqa: E501

        Returns a specified application, knowing its id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_get(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Application
        """
        kwargs['_return_http_data_only'] = True
        return self.application_get_with_http_info(application_id, **kwargs)  # noqa: E501

    def application_get_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """Get application  # noqa: E501

        Returns a specified application, knowing its id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_get_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Application, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_get`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "Application",
            404: None,
            500: "ErrorInfo",
        }

        return self.api_client.call_api(
            '/applications/{application_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_getcontainer(self, application_id, configuration, device_id, **kwargs):  # noqa: E501
        """Get container information  # noqa: E501

        Get detailed informations about container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getcontainer(application_id, configuration, device_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param device_id: Target device serial number (required)
        :type device_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DockerContainer
        """
        kwargs['_return_http_data_only'] = True
        return self.application_getcontainer_with_http_info(application_id, configuration, device_id, **kwargs)  # noqa: E501

    def application_getcontainer_with_http_info(self, application_id, configuration, device_id, **kwargs):  # noqa: E501
        """Get container information  # noqa: E501

        Get detailed informations about container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getcontainer_with_http_info(application_id, configuration, device_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param device_id: Target device serial number (required)
        :type device_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DockerContainer, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'device_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_getcontainer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_getcontainer`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_getcontainer`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if self.api_client.client_side_validation and ('device_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['device_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `device_id` when calling `application_getcontainer`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_getcontainer`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_getcontainer`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'device_id' in local_var_params and not re.search(r'^[-0-9a-zA-Z.]*$', local_var_params['device_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `device_id` when calling `application_getcontainer`, must conform to the pattern `/^[-0-9a-zA-Z.]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'device_id' in local_var_params and local_var_params['device_id'] is not None:  # noqa: E501
            query_params.append(('device_id', local_var_params['device_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "DockerContainer",
            404: None,
            500: "ErrorInfo",
            520: "ErrorInfo",
            525: "ErrorInfo",
            530: "ErrorInfo",
            533: "ErrorInfo",
            539: "ErrorInfo",
        }

        return self.api_client.call_api(
            '/applications/{application_id}/container', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_getcontainer_logs(self, application_id, configuration, device_id, **kwargs):  # noqa: E501
        """Get one of more lines from container logs  # noqa: E501

        Return one chunk of log (one or more lines), blocking if no data is available  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getcontainer_logs(application_id, configuration, device_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param device_id: Target device serial number (required)
        :type device_id: str
        :param restart: when true reads the lock back from beginning
        :type restart: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.application_getcontainer_logs_with_http_info(application_id, configuration, device_id, **kwargs)  # noqa: E501

    def application_getcontainer_logs_with_http_info(self, application_id, configuration, device_id, **kwargs):  # noqa: E501
        """Get one of more lines from container logs  # noqa: E501

        Return one chunk of log (one or more lines), blocking if no data is available  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getcontainer_logs_with_http_info(application_id, configuration, device_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param device_id: Target device serial number (required)
        :type device_id: str
        :param restart: when true reads the lock back from beginning
        :type restart: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'device_id',
            'restart'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_getcontainer_logs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_getcontainer_logs`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_getcontainer_logs`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if self.api_client.client_side_validation and ('device_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['device_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `device_id` when calling `application_getcontainer_logs`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_getcontainer_logs`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_getcontainer_logs`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'device_id' in local_var_params and not re.search(r'^[-0-9a-zA-Z.]*$', local_var_params['device_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `device_id` when calling `application_getcontainer_logs`, must conform to the pattern `/^[-0-9a-zA-Z.]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'device_id' in local_var_params and local_var_params['device_id'] is not None:  # noqa: E501
            query_params.append(('device_id', local_var_params['device_id']))  # noqa: E501
        if 'restart' in local_var_params and local_var_params['restart'] is not None:  # noqa: E501
            query_params.append(('restart', local_var_params['restart']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "str",
            204: None,
            404: None,
            500: "ErrorInfo",
            525: "ErrorInfo",
            539: "ErrorInfo",
        }

        return self.api_client.call_api(
            '/applications/{application_id}/container_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_getdocker_commandline(self, application_id, configuration, **kwargs):  # noqa: E501
        """Get docker command line to run the application/json  # noqa: E501

        Return the full docker command line that can be used to run the application container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getdocker_commandline(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.application_getdocker_commandline_with_http_info(application_id, configuration, **kwargs)  # noqa: E501

    def application_getdocker_commandline_with_http_info(self, application_id, configuration, **kwargs):  # noqa: E501
        """Get docker command line to run the application/json  # noqa: E501

        Return the full docker command line that can be used to run the application container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getdocker_commandline_with_http_info(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_getdocker_commandline" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_getdocker_commandline`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_getdocker_commandline`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_getdocker_commandline`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_getdocker_commandline`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "str",
            404: None,
            500: "ErrorInfo",
            525: "ErrorInfo",
            539: "ErrorInfo",
        }

        return self.api_client.call_api(
            '/applications/{application_id}/docker_commandline', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_getdocker_composefile(self, application_id, configuration, **kwargs):  # noqa: E501
        """Get docker compose file  # noqa: E501

        Return docker-compose file that can be used to run the application container and its dependencies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getdocker_composefile(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.application_getdocker_composefile_with_http_info(application_id, configuration, **kwargs)  # noqa: E501

    def application_getdocker_composefile_with_http_info(self, application_id, configuration, **kwargs):  # noqa: E501
        """Get docker compose file  # noqa: E501

        Return docker-compose file that can be used to run the application container and its dependencies  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getdocker_composefile_with_http_info(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_getdocker_composefile" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_getdocker_composefile`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_getdocker_composefile`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_getdocker_composefile`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_getdocker_composefile`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "str",
            404: None,
            500: "ErrorInfo",
            525: "ErrorInfo",
            539: "ErrorInfo",
        }

        return self.api_client.call_api(
            '/applications/{application_id}/docker_composefile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_getprivatekey(self, application_id, **kwargs):  # noqa: E501
        """Get the path of the RSA private key  # noqa: E501

        Retrieve the path of the private key that allows passwordless connection to the container. The application stores the public key inside the container if ssh is enabled (usually for debug builds only)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getprivatekey(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.application_getprivatekey_with_http_info(application_id, **kwargs)  # noqa: E501

    def application_getprivatekey_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """Get the path of the RSA private key  # noqa: E501

        Retrieve the path of the private key that allows passwordless connection to the container. The application stores the public key inside the container if ssh is enabled (usually for debug builds only)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getprivatekey_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_getprivatekey" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_getprivatekey`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_getprivatekey`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "str",
            404: None,
            500: "ErrorInfo",
        }

        return self.api_client.call_api(
            '/applications/{application_id}/privatekey', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_modify(self, application_id, **kwargs):  # noqa: E501
        """Change application properties  # noqa: E501

        Changes specified properties on an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_modify(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param application:
        :type application: Application
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Application
        """
        kwargs['_return_http_data_only'] = True
        return self.application_modify_with_http_info(application_id, **kwargs)  # noqa: E501

    def application_modify_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """Change application properties  # noqa: E501

        Changes specified properties on an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_modify_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param application:
        :type application: Application
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Application, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'application'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_modify" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_modify`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_modify`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'application' in local_var_params:
            body_params = local_var_params['application']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "Application",
            404: None,
            500: "ErrorInfo",
            531: "ErrorInfo",
            532: "ErrorInfo",
        }

        return self.api_client.call_api(
            '/applications/{application_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_push_to_registry(self, application_id, configuration, username, password, **kwargs):  # noqa: E501
        """Push application to docker registry  # noqa: E501

        Push application's container to a docker registry, using authentication  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_push_to_registry(application_id, configuration, username, password, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param username: (required)
        :type username: str
        :param password: (required)
        :type password: str
        :param progress_id: Id of a progress cookie (uuid)
        :type progress_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_push_to_registry_with_http_info(application_id, configuration, username, password, **kwargs)  # noqa: E501

    def application_push_to_registry_with_http_info(self, application_id, configuration, username, password, **kwargs):  # noqa: E501
        """Push application to docker registry  # noqa: E501

        Push application's container to a docker registry, using authentication  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_push_to_registry_with_http_info(application_id, configuration, username, password, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param username: (required)
        :type username: str
        :param password: (required)
        :type password: str
        :param progress_id: Id of a progress cookie (uuid)
        :type progress_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'username',
            'password',
            'progress_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_push_to_registry" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_push_to_registry`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_push_to_registry`")  # noqa: E501
        # verify the required parameter 'username' is set
        if self.api_client.client_side_validation and ('username' not in local_var_params or  # noqa: E501
                                                        local_var_params['username'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `username` when calling `application_push_to_registry`")  # noqa: E501
        # verify the required parameter 'password' is set
        if self.api_client.client_side_validation and ('password' not in local_var_params or  # noqa: E501
                                                        local_var_params['password'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `password` when calling `application_push_to_registry`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_push_to_registry`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_push_to_registry`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'progress_id' in local_var_params and not re.search(r'^$|[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['progress_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `progress_id` when calling `application_push_to_registry`, must conform to the pattern `/^$|[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'username' in local_var_params and local_var_params['username'] is not None:  # noqa: E501
            query_params.append(('username', local_var_params['username']))  # noqa: E501
        if 'password' in local_var_params and local_var_params['password'] is not None:  # noqa: E501
            query_params.append(('password', local_var_params['password']))  # noqa: E501
        if 'progress_id' in local_var_params and local_var_params['progress_id'] is not None:  # noqa: E501
            query_params.append(('progress_id', local_var_params['progress_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/applications/{application_id}/push_to_registry', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_reseal(self, application_id, **kwargs):  # noqa: E501
        """Clean id and keys from application configuration  # noqa: E501

        This operation make the application no longer valid, but allow you to upload it to a git repo from where it can be cloned/forked. Id and keys will be re-generated on next re-opening of the application, leading to different names for the images etc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_reseal(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_reseal_with_http_info(application_id, **kwargs)  # noqa: E501

    def application_reseal_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """Clean id and keys from application configuration  # noqa: E501

        This operation make the application no longer valid, but allow you to upload it to a git repo from where it can be cloned/forked. Id and keys will be re-generated on next re-opening of the application, leading to different names for the images etc.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_reseal_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_reseal" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_reseal`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_reseal`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/applications/{application_id}/reseal', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_run(self, application_id, configuration, device_id, **kwargs):  # noqa: E501
        """Run container image  # noqa: E501

        Run the application release or debug container on target, if the application is already running, restarts it  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_run(application_id, configuration, device_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param device_id: Target device serial number (required)
        :type device_id: str
        :param progress_id: Id of a progress cookie (uuid)
        :type progress_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DockerContainer
        """
        kwargs['_return_http_data_only'] = True
        return self.application_run_with_http_info(application_id, configuration, device_id, **kwargs)  # noqa: E501

    def application_run_with_http_info(self, application_id, configuration, device_id, **kwargs):  # noqa: E501
        """Run container image  # noqa: E501

        Run the application release or debug container on target, if the application is already running, restarts it  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_run_with_http_info(application_id, configuration, device_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param device_id: Target device serial number (required)
        :type device_id: str
        :param progress_id: Id of a progress cookie (uuid)
        :type progress_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DockerContainer, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'device_id',
            'progress_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_run" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_run`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_run`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if self.api_client.client_side_validation and ('device_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['device_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `device_id` when calling `application_run`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_run`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_run`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'device_id' in local_var_params and not re.search(r'^[-0-9a-zA-Z.]*$', local_var_params['device_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `device_id` when calling `application_run`, must conform to the pattern `/^[-0-9a-zA-Z.]*$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'progress_id' in local_var_params and not re.search(r'^$|[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['progress_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `progress_id` when calling `application_run`, must conform to the pattern `/^$|[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'device_id' in local_var_params and local_var_params['device_id'] is not None:  # noqa: E501
            query_params.append(('device_id', local_var_params['device_id']))  # noqa: E501
        if 'progress_id' in local_var_params and local_var_params['progress_id'] is not None:  # noqa: E501
            query_params.append(('progress_id', local_var_params['progress_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "DockerContainer",
            404: None,
            500: "ErrorInfo",
            520: "ErrorInfo",
            525: "ErrorInfo",
            530: "ErrorInfo",
            533: "ErrorInfo",
            539: "ErrorInfo",
            551: "ErrorInfo",
        }

        return self.api_client.call_api(
            '/applications/{application_id}/run', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_runsdk(self, application_id, configuration, **kwargs):  # noqa: E501
        """Run SDK containers  # noqa: E501

        Run SDK container and return its IP and SSH port  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_runsdk(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param build:
        :type build: bool
        :param progress_id: Id of a progress cookie (uuid)
        :type progress_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InlineResponse200
        """
        kwargs['_return_http_data_only'] = True
        return self.application_runsdk_with_http_info(application_id, configuration, **kwargs)  # noqa: E501

    def application_runsdk_with_http_info(self, application_id, configuration, **kwargs):  # noqa: E501
        """Run SDK containers  # noqa: E501

        Run SDK container and return its IP and SSH port  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_runsdk_with_http_info(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param build:
        :type build: bool
        :param progress_id: Id of a progress cookie (uuid)
        :type progress_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InlineResponse200, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'build',
            'progress_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_runsdk" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_runsdk`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_runsdk`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_runsdk`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_runsdk`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'progress_id' in local_var_params and not re.search(r'^$|[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['progress_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `progress_id` when calling `application_runsdk`, must conform to the pattern `/^$|[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'build' in local_var_params and local_var_params['build'] is not None:  # noqa: E501
            query_params.append(('build', local_var_params['build']))  # noqa: E501
        if 'progress_id' in local_var_params and local_var_params['progress_id'] is not None:  # noqa: E501
            query_params.append(('progress_id', local_var_params['progress_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "InlineResponse200",
            404: None,
            500: "ErrorInfo",
            520: "ErrorInfo",
            530: "ErrorInfo",
            551: "ErrorInfo",
        }

        return self.api_client.call_api(
            '/applications/{application_id}/sdk/run', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_sdk_container(self, application_id, configuration, **kwargs):  # noqa: E501
        """Get SDK container  # noqa: E501

        Get SDK container information (can be used to check if it's running)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_sdk_container(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DockerContainer
        """
        kwargs['_return_http_data_only'] = True
        return self.application_sdk_container_with_http_info(application_id, configuration, **kwargs)  # noqa: E501

    def application_sdk_container_with_http_info(self, application_id, configuration, **kwargs):  # noqa: E501
        """Get SDK container  # noqa: E501

        Get SDK container information (can be used to check if it's running)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_sdk_container_with_http_info(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DockerContainer, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_sdk_container" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_sdk_container`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_sdk_container`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_sdk_container`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_sdk_container`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "DockerContainer",
            204: None,
            404: None,
            500: "ErrorInfo",
            520: "ErrorInfo",
            530: "ErrorInfo",
            533: "ErrorInfo",
        }

        return self.api_client.call_api(
            '/applications/{application_id}/sdk/container', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_stop(self, application_id, configuration, device_id, **kwargs):  # noqa: E501
        """Stop running container image  # noqa: E501

        Stop application release or debug container currently running on target, operation succeeds even if the container is not running  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_stop(application_id, configuration, device_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param device_id: Target device serial number (required)
        :type device_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_stop_with_http_info(application_id, configuration, device_id, **kwargs)  # noqa: E501

    def application_stop_with_http_info(self, application_id, configuration, device_id, **kwargs):  # noqa: E501
        """Stop running container image  # noqa: E501

        Stop application release or debug container currently running on target, operation succeeds even if the container is not running  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_stop_with_http_info(application_id, configuration, device_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param device_id: Target device serial number (required)
        :type device_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'device_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_stop" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_stop`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_stop`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if self.api_client.client_side_validation and ('device_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['device_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `device_id` when calling `application_stop`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_stop`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_stop`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'device_id' in local_var_params and not re.search(r'^[-0-9a-zA-Z.]*$', local_var_params['device_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `device_id` when calling `application_stop`, must conform to the pattern `/^[-0-9a-zA-Z.]*$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'device_id' in local_var_params and local_var_params['device_id'] is not None:  # noqa: E501
            query_params.append(('device_id', local_var_params['device_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/applications/{application_id}/stop', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_syncfolders(self, application_id, sourcefolder, configuration, device_id, destfolder, **kwargs):  # noqa: E501
        """Synchronize folders  # noqa: E501

        Synchronizes folders between host/SDK container and the application container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_syncfolders(application_id, sourcefolder, configuration, device_id, destfolder, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param sourcefolder: (required)
        :type sourcefolder: str
        :param configuration: (required)
        :type configuration: str
        :param device_id: Target device serial number (required)
        :type device_id: str
        :param destfolder: (required)
        :type destfolder: str
        :param source_is_sdk:
        :type source_is_sdk: bool
        :param progress_id: Id of a progress cookie (uuid)
        :type progress_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_syncfolders_with_http_info(application_id, sourcefolder, configuration, device_id, destfolder, **kwargs)  # noqa: E501

    def application_syncfolders_with_http_info(self, application_id, sourcefolder, configuration, device_id, destfolder, **kwargs):  # noqa: E501
        """Synchronize folders  # noqa: E501

        Synchronizes folders between host/SDK container and the application container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_syncfolders_with_http_info(application_id, sourcefolder, configuration, device_id, destfolder, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param sourcefolder: (required)
        :type sourcefolder: str
        :param configuration: (required)
        :type configuration: str
        :param device_id: Target device serial number (required)
        :type device_id: str
        :param destfolder: (required)
        :type destfolder: str
        :param source_is_sdk:
        :type source_is_sdk: bool
        :param progress_id: Id of a progress cookie (uuid)
        :type progress_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'sourcefolder',
            'configuration',
            'device_id',
            'destfolder',
            'source_is_sdk',
            'progress_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_syncfolders" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_syncfolders`")  # noqa: E501
        # verify the required parameter 'sourcefolder' is set
        if self.api_client.client_side_validation and ('sourcefolder' not in local_var_params or  # noqa: E501
                                                        local_var_params['sourcefolder'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sourcefolder` when calling `application_syncfolders`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_syncfolders`")  # noqa: E501
        # verify the required parameter 'device_id' is set
        if self.api_client.client_side_validation and ('device_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['device_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `device_id` when calling `application_syncfolders`")  # noqa: E501
        # verify the required parameter 'destfolder' is set
        if self.api_client.client_side_validation and ('destfolder' not in local_var_params or  # noqa: E501
                                                        local_var_params['destfolder'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `destfolder` when calling `application_syncfolders`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_syncfolders`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_syncfolders`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'device_id' in local_var_params and not re.search(r'^[-0-9a-zA-Z.]*$', local_var_params['device_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `device_id` when calling `application_syncfolders`, must conform to the pattern `/^[-0-9a-zA-Z.]*$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'progress_id' in local_var_params and not re.search(r'^$|[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['progress_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `progress_id` when calling `application_syncfolders`, must conform to the pattern `/^$|[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'sourcefolder' in local_var_params and local_var_params['sourcefolder'] is not None:  # noqa: E501
            query_params.append(('sourcefolder', local_var_params['sourcefolder']))  # noqa: E501
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'device_id' in local_var_params and local_var_params['device_id'] is not None:  # noqa: E501
            query_params.append(('device_id', local_var_params['device_id']))  # noqa: E501
        if 'destfolder' in local_var_params and local_var_params['destfolder'] is not None:  # noqa: E501
            query_params.append(('destfolder', local_var_params['destfolder']))  # noqa: E501
        if 'source_is_sdk' in local_var_params and local_var_params['source_is_sdk'] is not None:  # noqa: E501
            query_params.append(('source_is_sdk', local_var_params['source_is_sdk']))  # noqa: E501
        if 'progress_id' in local_var_params and local_var_params['progress_id'] is not None:  # noqa: E501
            query_params.append(('progress_id', local_var_params['progress_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/applications/{application_id}/syncfolders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_updated(self, application_id, configuration, **kwargs):  # noqa: E501
        """Check if container image is up to date  # noqa: E501

        Check if some properties have been changed after the last build of the configuration-specific container image  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_updated(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bool
        """
        kwargs['_return_http_data_only'] = True
        return self.application_updated_with_http_info(application_id, configuration, **kwargs)  # noqa: E501

    def application_updated_with_http_info(self, application_id, configuration, **kwargs):  # noqa: E501
        """Check if container image is up to date  # noqa: E501

        Check if some properties have been changed after the last build of the configuration-specific container image  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_updated_with_http_info(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bool, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_updated" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_updated`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_updated`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_updated`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_updated`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "bool",
            404: None,
            500: "ErrorInfo",
            530: "ErrorInfo",
        }

        return self.api_client.call_api(
            '/applications/{application_id}/updated', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_updatesdk(self, application_id, configuration, **kwargs):  # noqa: E501
        """Update SDK container  # noqa: E501

        Update the SDK container by adding new dev libraries or synchronizing sysroots  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_updatesdk(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param progress_id: Id of a progress cookie (uuid)
        :type progress_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_updatesdk_with_http_info(application_id, configuration, **kwargs)  # noqa: E501

    def application_updatesdk_with_http_info(self, application_id, configuration, **kwargs):  # noqa: E501
        """Update SDK container  # noqa: E501

        Update the SDK container by adding new dev libraries or synchronizing sysroots  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_updatesdk_with_http_info(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param progress_id: Id of a progress cookie (uuid)
        :type progress_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'progress_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_updatesdk" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_updatesdk`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_updatesdk`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_updatesdk`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_updatesdk`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'progress_id' in local_var_params and not re.search(r'^$|[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['progress_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `progress_id` when calling `application_updatesdk`, must conform to the pattern `/^$|[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'progress_id' in local_var_params and local_var_params['progress_id'] is not None:  # noqa: E501
            query_params.append(('progress_id', local_var_params['progress_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {}

        return self.api_client.call_api(
            '/applications/{application_id}/sdk/update', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def applications_create(self, platform_id, path, **kwargs):  # noqa: E501
        """Create an application configuration  # noqa: E501

        Create a new application configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.applications_create(platform_id, path, async_req=True)
        >>> result = thread.get()

        :param platform_id: (required)
        :type platform_id: str
        :param path: (required)
        :type path: str
        :param username:
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Application
        """
        kwargs['_return_http_data_only'] = True
        return self.applications_create_with_http_info(platform_id, path, **kwargs)  # noqa: E501

    def applications_create_with_http_info(self, platform_id, path, **kwargs):  # noqa: E501
        """Create an application configuration  # noqa: E501

        Create a new application configuration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.applications_create_with_http_info(platform_id, path, async_req=True)
        >>> result = thread.get()

        :param platform_id: (required)
        :type platform_id: str
        :param path: (required)
        :type path: str
        :param username:
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Application, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'platform_id',
            'path',
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method applications_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'platform_id' is set
        if self.api_client.client_side_validation and ('platform_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['platform_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `platform_id` when calling `applications_create`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `applications_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'platform_id' in local_var_params and local_var_params['platform_id'] is not None:  # noqa: E501
            query_params.append(('platform_id', local_var_params['platform_id']))  # noqa: E501
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501
        if 'username' in local_var_params and local_var_params['username'] is not None:  # noqa: E501
            query_params.append(('username', local_var_params['username']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "Application",
            404: None,
            500: "ErrorInfo",
            531: "ErrorInfo",
            532: "ErrorInfo",
            540: "ErrorInfo",
        }

        return self.api_client.call_api(
            '/applications/create', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def applications_load(self, path, **kwargs):  # noqa: E501
        """Load an application configuration  # noqa: E501

        Load an application configuration from the local filesystem  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.applications_load(path, async_req=True)
        >>> result = thread.get()

        :param path: (required)
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Application
        """
        kwargs['_return_http_data_only'] = True
        return self.applications_load_with_http_info(path, **kwargs)  # noqa: E501

    def applications_load_with_http_info(self, path, **kwargs):  # noqa: E501
        """Load an application configuration  # noqa: E501

        Load an application configuration from the local filesystem  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.applications_load_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param path: (required)
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Application, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method applications_load" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `applications_load`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501
        
        response_types_map = {
            200: "Application",
            404: None,
            500: "ErrorInfo",
            531: "ErrorInfo",
            532: "ErrorInfo",
            540: "ErrorInfo",
        }

        return self.api_client.call_api(
            '/applications/load', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_types_map=response_types_map,
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
