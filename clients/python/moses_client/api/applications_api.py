# coding: utf-8

"""
    Torizon IDE-backend API

    Toradex API to build and deploy applications running as containers on Torizon  # noqa: E501

    The version of the OpenAPI document: 1.0.6
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from moses_client.api_client import ApiClient
from moses_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ApplicationsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def application_build(self, application_id, configuration, **kwargs):  # noqa: E501
        """Builds container image  # noqa: E501

        Builds application release or debug container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_build(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_build_with_http_info(application_id, configuration, **kwargs)  # noqa: E501

    def application_build_with_http_info(self, application_id, configuration, **kwargs):  # noqa: E501
        """Builds container image  # noqa: E501

        Builds application release or debug container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_build_with_http_info(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_build" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_build`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_build`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_build`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_build`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}/build', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_delete(self, application_id, **kwargs):  # noqa: E501
        """Remove an application and all the associated data and containers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_delete(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_delete_with_http_info(application_id, **kwargs)  # noqa: E501

    def application_delete_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """Remove an application and all the associated data and containers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_delete_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_delete`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_delete`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_deploy(self, application_id, configuration, deviceid, **kwargs):  # noqa: E501
        """Deploys container image  # noqa: E501

        Deploys application release or debug container to target  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_deploy(application_id, configuration, deviceid, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param deviceid: (required)
        :type deviceid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_deploy_with_http_info(application_id, configuration, deviceid, **kwargs)  # noqa: E501

    def application_deploy_with_http_info(self, application_id, configuration, deviceid, **kwargs):  # noqa: E501
        """Deploys container image  # noqa: E501

        Deploys application release or debug container to target  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_deploy_with_http_info(application_id, configuration, deviceid, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param deviceid: (required)
        :type deviceid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'deviceid'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_deploy" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_deploy`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_deploy`")  # noqa: E501
        # verify the required parameter 'deviceid' is set
        if self.api_client.client_side_validation and ('deviceid' not in local_var_params or  # noqa: E501
                                                        local_var_params['deviceid'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `deviceid` when calling `application_deploy`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_deploy`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_deploy`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'deviceid' in local_var_params and not re.search(r'^[0-9]{8}$', local_var_params['deviceid']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `deviceid` when calling `application_deploy`, must conform to the pattern `/^[0-9]{8}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'deviceid' in local_var_params and local_var_params['deviceid'] is not None:  # noqa: E501
            query_params.append(('deviceid', local_var_params['deviceid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}/deploy', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_get(self, application_id, **kwargs):  # noqa: E501
        """Get application  # noqa: E501

        Returns a specified application, knowing its id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_get(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Application
        """
        kwargs['_return_http_data_only'] = True
        return self.application_get_with_http_info(application_id, **kwargs)  # noqa: E501

    def application_get_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """Get application  # noqa: E501

        Returns a specified application, knowing its id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_get_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Application, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_get`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_get`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Application',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_getcontainer(self, application_id, configuration, deviceid, **kwargs):  # noqa: E501
        """Get container information  # noqa: E501

        Get informations about container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getcontainer(application_id, configuration, deviceid, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param deviceid: (required)
        :type deviceid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DockerContainer
        """
        kwargs['_return_http_data_only'] = True
        return self.application_getcontainer_with_http_info(application_id, configuration, deviceid, **kwargs)  # noqa: E501

    def application_getcontainer_with_http_info(self, application_id, configuration, deviceid, **kwargs):  # noqa: E501
        """Get container information  # noqa: E501

        Get informations about container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getcontainer_with_http_info(application_id, configuration, deviceid, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param deviceid: (required)
        :type deviceid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DockerContainer, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'deviceid'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_getcontainer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_getcontainer`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_getcontainer`")  # noqa: E501
        # verify the required parameter 'deviceid' is set
        if self.api_client.client_side_validation and ('deviceid' not in local_var_params or  # noqa: E501
                                                        local_var_params['deviceid'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `deviceid` when calling `application_getcontainer`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_getcontainer`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_getcontainer`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'deviceid' in local_var_params and not re.search(r'^[0-9]{8}$', local_var_params['deviceid']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `deviceid` when calling `application_getcontainer`, must conform to the pattern `/^[0-9]{8}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'deviceid' in local_var_params and local_var_params['deviceid'] is not None:  # noqa: E501
            query_params.append(('deviceid', local_var_params['deviceid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}/container', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DockerContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_getcontainer_logs(self, application_id, configuration, deviceid, **kwargs):  # noqa: E501
        """Get container log, line by line  # noqa: E501

        Return one line of log, blocking if no data is available  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getcontainer_logs(application_id, configuration, deviceid, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param deviceid: (required)
        :type deviceid: str
        :param restart: when true reads the lock back from beginning
        :type restart: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.application_getcontainer_logs_with_http_info(application_id, configuration, deviceid, **kwargs)  # noqa: E501

    def application_getcontainer_logs_with_http_info(self, application_id, configuration, deviceid, **kwargs):  # noqa: E501
        """Get container log, line by line  # noqa: E501

        Return one line of log, blocking if no data is available  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getcontainer_logs_with_http_info(application_id, configuration, deviceid, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param deviceid: (required)
        :type deviceid: str
        :param restart: when true reads the lock back from beginning
        :type restart: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'deviceid',
            'restart'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_getcontainer_logs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_getcontainer_logs`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_getcontainer_logs`")  # noqa: E501
        # verify the required parameter 'deviceid' is set
        if self.api_client.client_side_validation and ('deviceid' not in local_var_params or  # noqa: E501
                                                        local_var_params['deviceid'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `deviceid` when calling `application_getcontainer_logs`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_getcontainer_logs`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_getcontainer_logs`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'deviceid' in local_var_params and not re.search(r'^[0-9]{8}$', local_var_params['deviceid']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `deviceid` when calling `application_getcontainer_logs`, must conform to the pattern `/^[0-9]{8}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'deviceid' in local_var_params and local_var_params['deviceid'] is not None:  # noqa: E501
            query_params.append(('deviceid', local_var_params['deviceid']))  # noqa: E501
        if 'restart' in local_var_params and local_var_params['restart'] is not None:  # noqa: E501
            query_params.append(('restart', local_var_params['restart']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}/container_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_getprivatekey(self, application_id, **kwargs):  # noqa: E501
        """Retrieves the path of the RSA private key  # noqa: E501

        The application stores the public key inside the container if ssh is enabled, this key will allow passwordless connections to a running instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getprivatekey(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        return self.application_getprivatekey_with_http_info(application_id, **kwargs)  # noqa: E501

    def application_getprivatekey_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """Retrieves the path of the RSA private key  # noqa: E501

        The application stores the public key inside the container if ssh is enabled, this key will allow passwordless connections to a running instance  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_getprivatekey_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_getprivatekey" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_getprivatekey`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_getprivatekey`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}/privatekey', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_modify(self, application_id, **kwargs):  # noqa: E501
        """Change application properties  # noqa: E501

        Changes specified properties on an applicaton  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_modify(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param application:
        :type application: Application
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Application
        """
        kwargs['_return_http_data_only'] = True
        return self.application_modify_with_http_info(application_id, **kwargs)  # noqa: E501

    def application_modify_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """Change application properties  # noqa: E501

        Changes specified properties on an applicaton  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_modify_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param application:
        :type application: Application
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Application, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'application'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_modify" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_modify`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_modify`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'application' in local_var_params:
            body_params = local_var_params['application']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Application',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_reseal(self, application_id, **kwargs):  # noqa: E501
        """Cleans id and keys for git repo uploading  # noqa: E501

        This operation make the application no longer valid, but allow you to upload it to a git repo from where it can be cloned/forked re-generating new ids every time, avoiding that all clones share the same id/keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_reseal(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_reseal_with_http_info(application_id, **kwargs)  # noqa: E501

    def application_reseal_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """Cleans id and keys for git repo uploading  # noqa: E501

        This operation make the application no longer valid, but allow you to upload it to a git repo from where it can be cloned/forked re-generating new ids every time, avoiding that all clones share the same id/keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_reseal_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_reseal" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_reseal`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_reseal`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}/reseal', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_run(self, application_id, configuration, deviceid, **kwargs):  # noqa: E501
        """Runs container image  # noqa: E501

        Runs application release or debug container on target, if the application is already running, restarts it  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_run(application_id, configuration, deviceid, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param deviceid: (required)
        :type deviceid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DockerContainer
        """
        kwargs['_return_http_data_only'] = True
        return self.application_run_with_http_info(application_id, configuration, deviceid, **kwargs)  # noqa: E501

    def application_run_with_http_info(self, application_id, configuration, deviceid, **kwargs):  # noqa: E501
        """Runs container image  # noqa: E501

        Runs application release or debug container on target, if the application is already running, restarts it  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_run_with_http_info(application_id, configuration, deviceid, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param deviceid: (required)
        :type deviceid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DockerContainer, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'deviceid'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_run" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_run`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_run`")  # noqa: E501
        # verify the required parameter 'deviceid' is set
        if self.api_client.client_side_validation and ('deviceid' not in local_var_params or  # noqa: E501
                                                        local_var_params['deviceid'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `deviceid` when calling `application_run`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_run`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_run`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'deviceid' in local_var_params and not re.search(r'^[0-9]{8}$', local_var_params['deviceid']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `deviceid` when calling `application_run`, must conform to the pattern `/^[0-9]{8}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'deviceid' in local_var_params and local_var_params['deviceid'] is not None:  # noqa: E501
            query_params.append(('deviceid', local_var_params['deviceid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}/run', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DockerContainer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_runsdk(self, application_id, configuration, **kwargs):  # noqa: E501
        """Runs SDK containers  # noqa: E501

        Runs SDK container and return its IP and SSH port  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_runsdk(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param build:
        :type build: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: InlineResponse200
        """
        kwargs['_return_http_data_only'] = True
        return self.application_runsdk_with_http_info(application_id, configuration, **kwargs)  # noqa: E501

    def application_runsdk_with_http_info(self, application_id, configuration, **kwargs):  # noqa: E501
        """Runs SDK containers  # noqa: E501

        Runs SDK container and return its IP and SSH port  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_runsdk_with_http_info(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param build:
        :type build: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(InlineResponse200, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'build'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_runsdk" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_runsdk`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_runsdk`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_runsdk`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_runsdk`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'build' in local_var_params and local_var_params['build'] is not None:  # noqa: E501
            query_params.append(('build', local_var_params['build']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}/sdk/run', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_stop(self, application_id, configuration, deviceid, **kwargs):  # noqa: E501
        """Stops running container image  # noqa: E501

        Stops application release or debug container currently running on target  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_stop(application_id, configuration, deviceid, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param deviceid: (required)
        :type deviceid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_stop_with_http_info(application_id, configuration, deviceid, **kwargs)  # noqa: E501

    def application_stop_with_http_info(self, application_id, configuration, deviceid, **kwargs):  # noqa: E501
        """Stops running container image  # noqa: E501

        Stops application release or debug container currently running on target  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_stop_with_http_info(application_id, configuration, deviceid, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param deviceid: (required)
        :type deviceid: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration',
            'deviceid'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_stop" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_stop`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_stop`")  # noqa: E501
        # verify the required parameter 'deviceid' is set
        if self.api_client.client_side_validation and ('deviceid' not in local_var_params or  # noqa: E501
                                                        local_var_params['deviceid'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `deviceid` when calling `application_stop`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_stop`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_stop`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'deviceid' in local_var_params and not re.search(r'^[0-9]{8}$', local_var_params['deviceid']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `deviceid` when calling `application_stop`, must conform to the pattern `/^[0-9]{8}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'deviceid' in local_var_params and local_var_params['deviceid'] is not None:  # noqa: E501
            query_params.append(('deviceid', local_var_params['deviceid']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}/stop', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_syncfolders(self, application_id, sourcefolder, configuration, deviceid, destfolder, **kwargs):  # noqa: E501
        """synchronizes folders  # noqa: E501

        synchronizes folders between host/SDK container and application container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_syncfolders(application_id, sourcefolder, configuration, deviceid, destfolder, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param sourcefolder: (required)
        :type sourcefolder: str
        :param configuration: (required)
        :type configuration: str
        :param deviceid: (required)
        :type deviceid: str
        :param destfolder: (required)
        :type destfolder: str
        :param source_is_sdk:
        :type source_is_sdk: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_syncfolders_with_http_info(application_id, sourcefolder, configuration, deviceid, destfolder, **kwargs)  # noqa: E501

    def application_syncfolders_with_http_info(self, application_id, sourcefolder, configuration, deviceid, destfolder, **kwargs):  # noqa: E501
        """synchronizes folders  # noqa: E501

        synchronizes folders between host/SDK container and application container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_syncfolders_with_http_info(application_id, sourcefolder, configuration, deviceid, destfolder, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param sourcefolder: (required)
        :type sourcefolder: str
        :param configuration: (required)
        :type configuration: str
        :param deviceid: (required)
        :type deviceid: str
        :param destfolder: (required)
        :type destfolder: str
        :param source_is_sdk:
        :type source_is_sdk: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'sourcefolder',
            'configuration',
            'deviceid',
            'destfolder',
            'source_is_sdk'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_syncfolders" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_syncfolders`")  # noqa: E501
        # verify the required parameter 'sourcefolder' is set
        if self.api_client.client_side_validation and ('sourcefolder' not in local_var_params or  # noqa: E501
                                                        local_var_params['sourcefolder'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `sourcefolder` when calling `application_syncfolders`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_syncfolders`")  # noqa: E501
        # verify the required parameter 'deviceid' is set
        if self.api_client.client_side_validation and ('deviceid' not in local_var_params or  # noqa: E501
                                                        local_var_params['deviceid'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `deviceid` when calling `application_syncfolders`")  # noqa: E501
        # verify the required parameter 'destfolder' is set
        if self.api_client.client_side_validation and ('destfolder' not in local_var_params or  # noqa: E501
                                                        local_var_params['destfolder'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `destfolder` when calling `application_syncfolders`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_syncfolders`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_syncfolders`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        if self.api_client.client_side_validation and 'deviceid' in local_var_params and not re.search(r'^[0-9]{8}$', local_var_params['deviceid']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `deviceid` when calling `application_syncfolders`, must conform to the pattern `/^[0-9]{8}$/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'sourcefolder' in local_var_params and local_var_params['sourcefolder'] is not None:  # noqa: E501
            query_params.append(('sourcefolder', local_var_params['sourcefolder']))  # noqa: E501
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501
        if 'deviceid' in local_var_params and local_var_params['deviceid'] is not None:  # noqa: E501
            query_params.append(('deviceid', local_var_params['deviceid']))  # noqa: E501
        if 'destfolder' in local_var_params and local_var_params['destfolder'] is not None:  # noqa: E501
            query_params.append(('destfolder', local_var_params['destfolder']))  # noqa: E501
        if 'source_is_sdk' in local_var_params and local_var_params['source_is_sdk'] is not None:  # noqa: E501
            query_params.append(('source_is_sdk', local_var_params['source_is_sdk']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}/syncfolders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_updated(self, application_id, configuration, **kwargs):  # noqa: E501
        """Builds container image  # noqa: E501

        Builds application release or debug container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_updated(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bool
        """
        kwargs['_return_http_data_only'] = True
        return self.application_updated_with_http_info(application_id, configuration, **kwargs)  # noqa: E501

    def application_updated_with_http_info(self, application_id, configuration, **kwargs):  # noqa: E501
        """Builds container image  # noqa: E501

        Builds application release or debug container  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_updated_with_http_info(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bool, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_updated" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_updated`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_updated`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_updated`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_updated`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}/updated', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='bool',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def application_updatesdk(self, application_id, configuration, **kwargs):  # noqa: E501
        """Update SDK container  # noqa: E501

        Updates/rebuilds the SDK container by adding new dev libraries or synchronizing sysroots  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_updatesdk(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.application_updatesdk_with_http_info(application_id, configuration, **kwargs)  # noqa: E501

    def application_updatesdk_with_http_info(self, application_id, configuration, **kwargs):  # noqa: E501
        """Update SDK container  # noqa: E501

        Updates/rebuilds the SDK container by adding new dev libraries or synchronizing sysroots  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.application_updatesdk_with_http_info(application_id, configuration, async_req=True)
        >>> result = thread.get()

        :param application_id: Id of an application (uuid) (required)
        :type application_id: str
        :param configuration: (required)
        :type configuration: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        local_var_params = locals()

        all_params = [
            'application_id',
            'configuration'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method application_updatesdk" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `application_updatesdk`")  # noqa: E501
        # verify the required parameter 'configuration' is set
        if self.api_client.client_side_validation and ('configuration' not in local_var_params or  # noqa: E501
                                                        local_var_params['configuration'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `configuration` when calling `application_updatesdk`")  # noqa: E501

        if self.api_client.client_side_validation and 'application_id' in local_var_params and not re.search(r'^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$', local_var_params['application_id']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `application_id` when calling `application_updatesdk`, must conform to the pattern `/^[0-9,a-f,A-F]{8}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{4}-[0-9,a-f,A-F]{12}$/`")  # noqa: E501
        if self.api_client.client_side_validation and 'configuration' in local_var_params and not re.search(r'(?:debug|release)', local_var_params['configuration']):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `configuration` when calling `application_updatesdk`, must conform to the pattern `/(?:debug|release)/`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['application_id'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'configuration' in local_var_params and local_var_params['configuration'] is not None:  # noqa: E501
            query_params.append(('configuration', local_var_params['configuration']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/{application_id}/sdk/update', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def applications_create(self, platform_id, path, **kwargs):  # noqa: E501
        """Loads an application configuration  # noqa: E501

        Returns data about an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.applications_create(platform_id, path, async_req=True)
        >>> result = thread.get()

        :param platform_id: (required)
        :type platform_id: str
        :param path: (required)
        :type path: str
        :param username:
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Application
        """
        kwargs['_return_http_data_only'] = True
        return self.applications_create_with_http_info(platform_id, path, **kwargs)  # noqa: E501

    def applications_create_with_http_info(self, platform_id, path, **kwargs):  # noqa: E501
        """Loads an application configuration  # noqa: E501

        Returns data about an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.applications_create_with_http_info(platform_id, path, async_req=True)
        >>> result = thread.get()

        :param platform_id: (required)
        :type platform_id: str
        :param path: (required)
        :type path: str
        :param username:
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Application, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'platform_id',
            'path',
            'username'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method applications_create" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'platform_id' is set
        if self.api_client.client_side_validation and ('platform_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['platform_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `platform_id` when calling `applications_create`")  # noqa: E501
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `applications_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'platform_id' in local_var_params and local_var_params['platform_id'] is not None:  # noqa: E501
            query_params.append(('platform_id', local_var_params['platform_id']))  # noqa: E501
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501
        if 'username' in local_var_params and local_var_params['username'] is not None:  # noqa: E501
            query_params.append(('username', local_var_params['username']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/create', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Application',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))

    def applications_load(self, path, **kwargs):  # noqa: E501
        """Loads an application configuration  # noqa: E501

        Returns data about an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.applications_load(path, async_req=True)
        >>> result = thread.get()

        :param path: (required)
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Application
        """
        kwargs['_return_http_data_only'] = True
        return self.applications_load_with_http_info(path, **kwargs)  # noqa: E501

    def applications_load_with_http_info(self, path, **kwargs):  # noqa: E501
        """Loads an application configuration  # noqa: E501

        Returns data about an application  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.applications_load_with_http_info(path, async_req=True)
        >>> result = thread.get()

        :param path: (required)
        :type path: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Application, status_code(int), headers(HTTPHeaderDict))
        """

        local_var_params = locals()

        all_params = [
            'path'
        ]
        all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth'
            ]
        )

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method applications_load" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'path' is set
        if self.api_client.client_side_validation and ('path' not in local_var_params or  # noqa: E501
                                                        local_var_params['path'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `path` when calling `applications_load`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/applications/load', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Application',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats,
            _request_auth=local_var_params.get('_request_auth'))
